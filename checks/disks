#!/usr/bin/python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2013             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# ails.  You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

# <<<diskstat>>>
# 1300264105
#    8       0 sda 691860 951191 13559915 491748 234686 197346 3359512 94944 0 56844 586312
#    8      32 sdb 791860 91191 23589915 491748 234686 197346 3359512 94944 0 56844 586312

# Newer agent output also dm-* and Veritas devices and if
# available the following additional information for name rewriting:

# <<<diskstat>>>
# 1338931242
#    8       0 sda 6142 327 219612 2244 3190 6233 74075 8206 0 6523 10446
#  253       0 dm-0 4579 0 181754 2343 9249 0 73960 259491 0 1208 261833
#  253       1 dm-1 342 0 2736 47 3 0 11796464 5016 0 5063 5063
#  253       2 dm-2 160 0 1274 27 11 0 56 3 0 27 30
#    8      16 sdb 464 858 7717 336 1033 0 311454 3899 0 3007 4231
#    8      32 sdc 855 13352 106777 1172 915 0 154467 2798 0 3012 3967
#    8      48 sdd 1217 861 109802 1646 118 0 56151 1775 0 2736 3420
#    8      80 sdf 359 1244 58323 792 66 0 4793 388 0 765 1178
#    8      64 sde 310 1242 6964 268 118 0 56151 1607 0 1307 1872
#    8      96 sdg 1393 1242 314835 3759 129 0 56172 1867 0 4027 5619
#  199   27000 VxVM27000 131 0 990 61 11 0 21 29 0 89 90
#  199   27001 VxVM27001 0 0 0 0 0 0 0 0 0 0 0
# [dmsetup_info]
# vg_zwei-lv_home 253:2 vg_zwei lv_home
# vg_zwei-lv_swap 253:1 vg_zwei lv_swap
# vg_zwei-lv_root 253:0 vg_zwei lv_root
# [vx_dsk]
# c7 6978 /dev/vx/dsk/datadg/lalavol
# c7 6979 /dev/vx/dsk/datadg/oravol

# Fields in /proc/diskstats
#  Index 0 -- major number
#  Index 1 -- minor number
#  Index 2 -- device name                        --> used by check
#  Index 3 -- # of reads issued
#  Index 4 -- # of reads merged
#  Index 5 -- # of sectors read (a 512 Byte)     --> used by check
#  Index 6 -- # of milliseconds spent reading
#  Index 7 -- # of writes completed
#  Index 8 -- # of writes merged
#  Index 9 -- # of sectors written (a 512 Byte)  --> used by check
#  Index 10 -- # of milliseconds spent writing
#  Index 11 -- # of I/Os currently in progress
#  Index 12 -- # of milliseconds spent doing I/Os
#  Index 13 -- weighted # of milliseconds spent doing I/Os

check_includes['diskstat'] = [ "diskstat.include" ]

# Convert information to generic format also generated
# by winperf_phydisk
# [ now, [( disk, readctr, writectr ), ... ]]
# where counters are in sectors (512 bytes)

def diskstat_parse_info(info):
    info_plain = []
    nameinfo = {}
    phase = 'info'
    for line in info:
        if line[0] == '[dmsetup_info]':
            phase = 'dmsetup_info'
        elif line[0] == '[vx_dsk]':
            phase = 'vx_dsk'
        else:
            if phase == 'info':
                info_plain.append(line)
            elif phase == 'dmsetup_info':
                try:
                    majmin = tuple(map(int, line[1].split(':')))
                    if len(line) == 4:
                        name = "LVM %s" % line[0]
                    else:
                        name = "DM %s" % line[0]
                    nameinfo[majmin] = name
                except:
                    pass # ignore such crap as "No Devices Found"
            elif phase == 'vx_dsk':
                maj = int(line[0], 16)
                min = int(line[1], 16)
                group, disk = line[2].split('/')[-2:]
                name = "VxVM %s-%s" % (group, disk)
                nameinfo[(maj, min)] = name

    return info_plain, nameinfo

def diskstat_rewrite_device(nameinfo, linestart):
    major, minor = map(int, linestart[:2])
    device = linestart[2]
    return nameinfo.get((major, minor), device)

def linux_diskstat_convert(info):
    info, nameinfo = diskstat_parse_info(info)
    # The generic function takes the following values per line:
    #  0: devname
    #  1: read bytes counter
    #  2: write bytes counter
    # Optional ones:
    #  3: number of reads
    #  4: number of writes
    #  5: timems
    #  6: read queue length *counters*
    #  7: write queue length *counters*
    rewritten = [
        ( diskstat_rewrite_device(nameinfo, l[0:3]),
        int(l[5]),
        int(l[9]),
        int(l[3]),
        int(l[7]),
        int(l[12])
        ) for l in info[1:] if len(l) >= 13
    ]

    # Remove device mapper devices without a translated name
    return [ line for line in rewritten if not line[0].startswith("dm-") ]

def inventory_disk(info):
    return [( "SUMMARY", "diskstat_default_levels" )]
#    return inventory_diskstat_generic(linux_diskstat_convert(info))

def check_disks(item, params, info):
    if not info:
        return (3, "UNKNOW - no output from plugin")
    this_time = int(time.time())
    disks = devices.Disks(info)
    average_range = params.get("average")
    perfdata = []
    infos = []
    status = 0
    disks_get = disks.get_device_dict()['disks']
    for disk in disks_get:
        for what, ctr in [ ("read-" + disk['name'],  disk['readTput']), ("write-", disk['writeTput']) ]:
            countername = "disk.%s.%s" % (item, what)

            # unpack levels now, need also for perfdata
            levels = params.get(what)
            if levels:
                warn, crit = levels
            else:
                warn, crit = None, None

            # compute IO rate in bytes/sec
            timedif, sectors_per_sec = get_counter(countername, this_time, int(ctr))
            bytes_per_sec = sectors_per_sec * 512
            if what == ("read-" + disk['name']):
                disk['readTput'] = bytes_per_sec
            else:
                disk['writeTput'] = bytes_per_sec
            infos.append("%s/sec %s" % (get_bytes_human_readable(bytes_per_sec), what))
            perfdata.append( (what, bytes_per_sec, warn, crit) )

            # compute average of the rate over ___ minutes
            if average_range != None:
                timedif, avg = get_average(countername + ".avg", this_time, bytes_per_sec, average_range)
                perfdata.append( (what + ".avg", avg) )
                bytes_per_sec = avg

            # check levels
            if levels != None:
                mb_per_sec = bytes_per_sec / 1048576
                if mb_per_sec >= crit:
                    status = 2
                    infos[-1] += "(!!)"
                elif mb_per_sec >= warn:
                    status = max(status, 1)
                    infos[-1] += "(!)"

        # Add performance data for averaged IO
        if average_range != None:
            perfdata = [ perfdata[0], perfdata[2], perfdata[1], perfdata[3] ]

        countername = "disk.%s" % item
        # Process IOs when available
        ios_per_sec = None
        timedif, ios_per_sec = get_counter(countername + ".ios-" + disk['name'], this_time, disk['iops'])
        disk['iops'] = ios_per_sec
        infos.append("IOs-%s: %.2f/sec" % (disk['name'], ios_per_sec))

        perfdata.append(("ios-" + disk['name'], ios_per_sec))

        # Do Latency computation if this information is available:
        timedif, timems_per_sec = get_counter(countername + ".time-" + disk['name'], this_time, disk['latency'])
        if not ios_per_sec:
            latency = 0.0
            disk['latency'] = 0.0
        else:
            latency = timems_per_sec / ios_per_sec
            disk['latency']  = Latency
        infos.append("Latency-%s: %.2fms" % (disk['name'], latency))
        if "latency" in params:
            warn, crit = params["latency"]
            if latency >= crit:
                status = 2
                infos[-1] += "(!!)"
            elif latency >= warn:
                status = max(status, 1)
                infos[-1] += "(!)"
        else:
            warn, crit = None, None

        perfdata.append(("latency-" + disk['name'], latency))
    disks.update_device('disks'=disks_get)

    return (status, nagios_state_names[status] + " - " + ", ".join(infos) , perfdata)

check_info['disks'] = (check_disks, "Disks %s", 1,  inventory_disk)
checkgroup_of["disks"] = "disks"

